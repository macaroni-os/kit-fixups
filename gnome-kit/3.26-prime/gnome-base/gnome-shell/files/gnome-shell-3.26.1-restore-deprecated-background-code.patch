diff '--exclude=.git' -urN a/js/ui/background.js b/js/ui/background.js
--- a/js/ui/background.js	2017-10-04 12:14:12.000000000 -0400
+++ b/js/ui/background.js	2017-10-11 19:51:22.387379987 -0400
@@ -1,98 +1,5 @@
 // -*- mode: js; js-indent-level: 4; indent-tabs-mode: nil -*-
 
-// READ THIS FIRST
-// Background handling is a maze of objects, both objects in this file, and
-// also objects inside Mutter. They all have a role.
-//
-// BackgroundManager
-//   The only object that other parts of GNOME Shell deal with; a
-//   BackgroundManager creates background actors and adds them to
-//   the specified container. When the background is changed by the
-//   user it will fade out the old actor and fade in the new actor.
-//   (This is separate from the fading for an animated background,
-//   since using two actors is quite inefficient.)
-//
-// MetaBackgroundImage
-//   An object represented an image file that will be used for drawing
-//   the background. MetaBackgroundImage objects asynchronously load,
-//   so they are first created in an unloaded state, then later emit
-//   a ::loaded signal when the Cogl object becomes available.
-//
-// MetaBackgroundImageCache
-//   A cache from filename to MetaBackgroundImage.
-//
-// BackgroundSource
-//   An object that is created for each GSettings schema (separate
-//   settings schemas are used for the lock screen and main background),
-//   and holds a reference to shared Background objects.
-//
-// MetaBackground
-//   Holds the specification of a background - a background color
-//   or gradient and one or two images blended together.
-//
-// Background
-//   JS delegate object that Connects a MetaBackground to the GSettings
-//   schema for the background.
-//
-// Animation
-//   A helper object that handles loading a XML-based animation; it is a
-//   wrapper for GnomeDesktop.BGSlideShow
-//
-// MetaBackgroundActor
-//   An actor that draws the background for a single monitor
-//
-// BackgroundCache
-//   A cache of Settings schema => BackgroundSource and of a single Animation.
-//   Also used to share file monitors.
-//
-// A static image, background color or gradient is relatively straightforward. The
-// calling code creates a separate BackgroundManager for each monitor. Since they
-// are created for the same GSettings schema, they will use the same BackgroundSource
-// object, which provides a single Background and correspondingly a single
-// MetaBackground object.
-//
-// BackgroundManager               BackgroundManager
-//        |        \               /        |
-//        |         BackgroundSource        |        looked up in BackgroundCache
-//        |                |                |
-//        |            Background           |
-//        |                |                |
-//   MetaBackgroundActor   |    MetaBackgroundActor
-//         \               |               /
-//          `------- MetaBackground ------'
-//                         |
-//                MetaBackgroundImage            looked up in MetaBackgroundImageCache
-//
-// The animated case is tricker because the animation XML file can specify different
-// files for different monitor resolutions and aspect ratios. For this reason,
-// the BackgroundSource provides different Background share a single Animation object,
-// which tracks the animation, but use different MetaBackground objects. In the
-// common case, the different MetaBackground objects will be created for the
-// same filename and look up the *same* MetaBackgroundImage object, so there is
-// little wasted memory:
-//
-// BackgroundManager               BackgroundManager
-//        |        \               /        |
-//        |         BackgroundSource        |        looked up in BackgroundCache
-//        |             /      \            |
-//        |     Background   Background     |
-//        |       |     \      /   |        |
-//        |       |    Animation   |        |        looked up in BackgroundCache
-// MetaBackgroundA|tor           Me|aBackgroundActor
-//         \      |                |       /
-//      MetaBackground           MetaBackground
-//                 \                 /
-//                MetaBackgroundImage            looked up in MetaBackgroundImageCache
-//                MetaBackgroundImage
-//
-// But the case of different filenames and different background images
-// is possible as well:
-//                        ....
-//      MetaBackground              MetaBackground
-//             |                          |
-//     MetaBackgroundImage         MetaBackgroundImage
-//     MetaBackgroundImage         MetaBackgroundImage
-
 const Clutter = imports.gi.Clutter;
 const GDesktopEnums = imports.gi.GDesktopEnums;
 const Gio = imports.gi.Gio;
@@ -107,8 +14,6 @@
 const Params = imports.misc.params;
 const Tweener = imports.ui.tweener;
 
-var DEFAULT_BACKGROUND_COLOR = Clutter.Color.from_pixel(0x2e3436ff);
-
 const BACKGROUND_SCHEMA = 'org.gnome.desktop.background';
 const PRIMARY_COLOR_KEY = 'primary-color';
 const SECONDARY_COLOR_KEY = 'secondary-color';
@@ -128,50 +33,246 @@
 
 let _backgroundCache = null;
 
-function _fileEqual0(file1, file2) {
-    if (file1 == file2)
-        return true;
-
-    if (!file1 || !file2)
-        return false;
-
-    return file1.equal(file2);
-}
-
 var BackgroundCache = new Lang.Class({
     Name: 'BackgroundCache',
 
     _init: function() {
+        this._patterns = [];
+        this._images = [];
+        this._pendingFileLoads = [];
         this._fileMonitors = {};
-        this._backgroundSources = {};
         this._animations = {};
     },
 
-    monitorFile: function(file) {
-        let key = file.hash();
-        if (this._fileMonitors[key])
+    getPatternContent: function(params) {
+        params = Params.parse(params, { monitorIndex: 0,
+                                        color: null,
+                                        secondColor: null,
+                                        shadingType: null,
+                                        effects: Meta.BackgroundEffects.NONE });
+
+        let content = null;
+
+        let candidateContent = null;
+        for (let i = 0; i < this._patterns.length; i++) {
+            if (this._patterns[i].get_shading() != params.shadingType)
+                continue;
+
+            if (!params.color.equal(this._patterns[i].get_color()))
+                continue;
+
+            if (params.shadingType != GDesktopEnums.BackgroundShading.SOLID &&
+                !params.secondColor.equal(this._patterns[i].get_second_color()))
+                continue;
+
+            candidateContent = this._patterns[i];
+
+            if (params.effects != this._patterns[i].effects)
+                continue;
+
+            break;
+        }
+
+        if (candidateContent) {
+            content = candidateContent.copy(params.monitorIndex, params.effects);
+        } else {
+            content = new Meta.Background({ meta_screen: global.screen,
+                                            monitor: params.monitorIndex,
+                                            effects: params.effects });
+
+            if (params.shadingType == GDesktopEnums.BackgroundShading.SOLID) {
+                content.load_color(params.color);
+            } else {
+                content.load_gradient(params.shadingType, params.color, params.secondColor);
+            }
+        }
+
+        this._patterns.push(content);
+        return content;
+    },
+
+    _monitorFile: function(filename) {
+        if (this._fileMonitors[filename])
             return;
 
+        let file = Gio.File.new_for_path(filename);
         let monitor = file.monitor(Gio.FileMonitorFlags.NONE, null);
-        monitor.connect('changed',
-                        Lang.bind(this, function(obj, file, otherFile, eventType) {
-                            // Ignore CHANGED and CREATED events, since in both cases
-                            // we'll get a CHANGES_DONE_HINT event when done.
-                            if (eventType != Gio.FileMonitorEvent.CHANGED &&
-                                eventType != Gio.FileMonitorEvent.CREATED)
-                                this.emit('file-changed', file);
-                        }));
 
-        this._fileMonitors[key] = monitor;
+        let signalId = monitor.connect('changed',
+                                       Lang.bind(this, function() {
+                                           for (let i = 0; i < this._images.length; i++) {
+                                               if (this._images[i].get_filename() == filename)
+                                                   this._images.splice(i, 1);
+                                           }
+
+                                           monitor.disconnect(signalId);
+
+                                           this.emit('file-changed', filename);
+                                       }));
+
+        this._fileMonitors[filename] = monitor;
+    },
+
+    _removeContent: function(contentList, content) {
+        let index = contentList.indexOf(content);
+        if (index < 0)
+            throw new Error("Trying to remove invalid content: " + content);
+        contentList.splice(index, 1);
+    },
+
+    removePatternContent: function(content) {
+        this._removeContent(this._patterns, content);
+    },
+
+    removeImageContent: function(content) {
+        let filename = content.get_filename();
+
+        let hasOtherUsers = this._images.some(function(content) { return filename == content.get_filename(); });
+        if (!hasOtherUsers)
+            delete this._fileMonitors[filename];
+
+        this._removeContent(this._images, content);
+    },
+
+    _attachCallerToFileLoad: function(caller, fileLoad) {
+        fileLoad.callers.push(caller);
+
+        if (!caller.cancellable)
+            return;
+
+        caller.cancellable.connect(Lang.bind(this, function() {
+            let idx = fileLoad.callers.indexOf(caller);
+            fileLoad.callers.splice(idx, 1);
+
+            if (fileLoad.callers.length == 0) {
+                fileLoad.cancellable.cancel();
+
+                let idx = this._pendingFileLoads.indexOf(fileLoad);
+                this._pendingFileLoads.splice(idx, 1);
+            }
+        }));
+    },
+
+    _loadImageContent: function(params) {
+        params = Params.parse(params, { monitorIndex: 0,
+                                        style: null,
+                                        filename: null,
+                                        effects: Meta.BackgroundEffects.NONE,
+                                        cancellable: null,
+                                        onFinished: null });
+
+        let caller = { monitorIndex: params.monitorIndex,
+                       effects: params.effects,
+                       cancellable: params.cancellable,
+                       onFinished: params.onFinished };
+
+        for (let i = 0; i < this._pendingFileLoads.length; i++) {
+            let fileLoad = this._pendingFileLoads[i];
+
+            if (fileLoad.filename == params.filename &&
+                fileLoad.style == params.style) {
+                this._attachCallerToFileLoad(caller, fileLoad);
+                return;
+            }
+        }
+
+        let fileLoad = { filename: params.filename,
+                         style: params.style,
+                         cancellable: new Gio.Cancellable(),
+                         callers: [] };
+        this._attachCallerToFileLoad(caller, fileLoad);
+
+        let content = new Meta.Background({ meta_screen: global.screen });
+
+        content.load_file_async(params.filename,
+                                params.style,
+                                params.cancellable,
+                                Lang.bind(this,
+                                          function(object, result) {
+                                              try {
+                                                  content.load_file_finish(result);
+
+                                                  this._monitorFile(params.filename);
+                                              } catch(e) {
+                                                  content = null;
+                                              }
+
+                                              for (let i = 0; i < fileLoad.callers.length; i++) {
+                                                  let caller = fileLoad.callers[i];
+                                                  if (caller.onFinished) {
+                                                      let newContent;
+
+                                                      if (content) {
+                                                          newContent = content.copy(caller.monitorIndex, caller.effects);
+                                                          this._images.push(newContent);
+                                                      }
+
+                                                      caller.onFinished(newContent);
+                                                  }
+                                              }
+
+                                              let idx = this._pendingFileLoads.indexOf(fileLoad);
+                                              this._pendingFileLoads.splice(idx, 1);
+                                          }));
+    },
+
+    getImageContent: function(params) {
+        params = Params.parse(params, { monitorIndex: 0,
+                                        style: null,
+                                        filename: null,
+                                        effects: Meta.BackgroundEffects.NONE,
+                                        cancellable: null,
+                                        onFinished: null });
+
+        let content = null;
+
+        let candidateContent = null;
+        for (let i = 0; i < this._images.length; i++) {
+            if (this._images[i].get_style() != params.style)
+                continue;
+
+            if (this._images[i].get_filename() != params.filename)
+                continue;
+
+            if (params.style == GDesktopEnums.BackgroundStyle.SPANNED &&
+                this._images[i].monitor != params.monitorIndex)
+                continue;
+
+            candidateContent = this._images[i];
+
+            if (params.effects != this._images[i].effects)
+                continue;
+
+            break;
+        }
+
+        if (candidateContent) {
+            content = candidateContent.copy(params.monitorIndex, params.effects);
+
+            if (params.cancellable && params.cancellable.is_cancelled())
+                content = null;
+            else
+                this._images.push(content);
+
+            if (params.onFinished)
+                params.onFinished(content);
+        } else {
+            this._loadImageContent({ filename: params.filename,
+                                     style: params.style,
+                                     effects: params.effects,
+                                     monitorIndex: params.monitorIndex,
+                                     cancellable: params.cancellable,
+                                     onFinished: params.onFinished });
+
+        }
     },
 
     getAnimation: function(params) {
-        params = Params.parse(params, { file: null,
+        params = Params.parse(params, { filename: null,
                                         settingsSchema: null,
                                         onLoaded: null });
 
-        let animation = this._animations[params.settingsSchema];
-        if (animation && _fileEqual0(animation.file, params.file)) {
+        if (this._animations[params.settingsSchema] && this._animationFilename == params.filename) {
             if (params.onLoaded) {
                 let id = GLib.idle_add(GLib.PRIORITY_DEFAULT, Lang.bind(this, function() {
                     params.onLoaded(this._animations[params.settingsSchema]);
@@ -182,9 +283,11 @@
             return;
         }
 
-        animation = new Animation({ file: params.file });
+        let animation = new Animation({ filename: params.filename });
 
         animation.load(Lang.bind(this, function() {
+                           this._monitorFile(params.filename);
+                           this._animationFilename = params.filename;
                            this._animations[params.settingsSchema] = animation;
 
                            if (params.onLoaded) {
@@ -195,31 +298,6 @@
                                GLib.Source.set_name_by_id(id, '[gnome-shell] params.onLoaded');
                            }
                        }));
-    },
-
-    getBackgroundSource: function(layoutManager, settingsSchema) {
-        // The layoutManager is always the same one; we pass in it since
-        // Main.layoutManager may not be set yet
-
-        if (!(settingsSchema in this._backgroundSources)) {
-            this._backgroundSources[settingsSchema] = new BackgroundSource(layoutManager, settingsSchema);
-            this._backgroundSources[settingsSchema]._useCount = 1;
-        } else {
-            this._backgroundSources[settingsSchema]._useCount++;
-        }
-
-        return this._backgroundSources[settingsSchema];
-    },
-
-    releaseBackgroundSource: function(settingsSchema) {
-        if (settingsSchema in this._backgroundSources) {
-            let source = this._backgroundSources[settingsSchema];
-            source._useCount--;
-            if (source._useCount == 0) {
-                delete this._backgroundSources[settingsSchema];
-                source.destroy();
-            }
-        }
     }
 });
 Signals.addSignalMethods(BackgroundCache.prototype);
@@ -236,19 +314,28 @@
     _init: function(params) {
         params = Params.parse(params, { monitorIndex: 0,
                                         layoutManager: Main.layoutManager,
+                                        effects: Meta.BackgroundEffects.NONE,
                                         settings: null,
-                                        file: null,
-                                        style: null });
+                                        overrideImage: null });
+        this.actor = new Meta.BackgroundGroup();
+        this.actor._delegate = this;
 
-        this.background = new Meta.Background({ meta_screen: global.screen });
-        this.background._delegate = this;
+        this._destroySignalId = this.actor.connect('destroy',
+                                                   Lang.bind(this, this._destroy));
 
         this._settings = params.settings;
-        this._file = params.file;
-        this._style = params.style;
+        this._overrideImage = params.overrideImage;
         this._monitorIndex = params.monitorIndex;
         this._layoutManager = params.layoutManager;
+        this._effects = params.effects;
         this._fileWatches = {};
+        this._pattern = null;
+        // contains a single image for static backgrounds and
+        // two images (from and to) for slide shows
+        this._images = {};
+
+        this._brightness = 1.0;
+        this._vignetteSharpness = 0.2;
         this._cancellable = new Gio.Cancellable();
         this.isLoaded = false;
 
@@ -256,7 +343,7 @@
         this._timezoneChangedId = this._clock.connect('notify::timezone',
             Lang.bind(this, function() {
                 if (this._animation)
-                    this._loadAnimation(this._animation.file);
+                    this._loadAnimation(this._animation.filename);
             }));
 
         let loginManager = LoginManager.getLoginManager();
@@ -274,7 +361,7 @@
         this._load();
     },
 
-    destroy: function() {
+    _destroy: function() {
         this._cancellable.cancel();
         this._removeAnimationTimeout();
 
@@ -293,16 +380,33 @@
             LoginManager.getLoginManager().disconnect(this._prepareForSleepId);
         this._prepareForSleepId = 0;
 
+        if (this._pattern) {
+            if (this._pattern.content)
+                this._cache.removePatternContent(this._pattern.content);
+
+            this._pattern.destroy();
+            this._pattern = null;
+        }
+
+        keys = Object.keys(this._images);
+        for (i = 0; i < keys.length; i++) {
+            let actor = this._images[keys[i]];
+
+            if (actor.content)
+                this._cache.removeImageContent(actor.content);
+
+            actor.destroy();
+            this._images[keys[i]] = null;
+        }
+
+        this.actor.disconnect(this._destroySignalId);
+        this._destroySignalId = 0;
+
         if (this._settingsChangedSignalId != 0)
             this._settings.disconnect(this._settingsChangedSignalId);
         this._settingsChangedSignalId = 0;
     },
 
-    updateResolution: function() {
-        if (this._animation)
-            this._refreshAnimation();
-    },
-
     _refreshAnimation: function() {
         if (!this._animation)
             return;
@@ -334,27 +438,54 @@
 
         let shadingType = this._settings.get_enum(COLOR_SHADING_TYPE_KEY);
 
-        if (shadingType == GDesktopEnums.BackgroundShading.SOLID)
-            this.background.set_color(color);
-        else
-            this.background.set_gradient(shadingType, color, secondColor);
+        let content = this._cache.getPatternContent({ monitorIndex: this._monitorIndex,
+                                                      effects: this._effects,
+                                                      color: color,
+                                                      secondColor: secondColor,
+                                                      shadingType: shadingType });
+
+        this._pattern = new Meta.BackgroundActor();
+        this.actor.add_child(this._pattern);
+
+        this._pattern.content = content;
     },
 
-    _watchFile: function(file) {
-        let key = file.hash();
-        if (this._fileWatches[key])
+    _watchCacheFile: function(filename) {
+        if (this._fileWatches[filename])
             return;
 
-        this._cache.monitorFile(file);
         let signalId = this._cache.connect('file-changed',
                                            Lang.bind(this, function(cache, changedFile) {
-                                               if (changedFile.equal(file)) {
+                                               if (changedFile == filename) {
                                                    let imageCache = Meta.BackgroundImageCache.get_default();
                                                    imageCache.purge(changedFile);
                                                    this.emit('changed');
                                                }
                                            }));
-        this._fileWatches[key] = signalId;
+        this._fileWatches[filename] = signalId;
+    },
+
+    _ensureImage: function(index) {
+        if (this._images[index])
+            return;
+
+        let actor = new Meta.BackgroundActor();
+
+        // The background pattern is the first actor in
+        // the group, and all images should be above that.
+        this.actor.insert_child_at_index(actor, index + 1);
+        this._images[index] = actor;
+    },
+
+    _updateImage: function(index, content, filename) {
+        content.brightness = this._brightness;
+        content.vignette_sharpness = this._vignetteSharpness;
+
+        let image = this._images[index];
+        if (image.content)
+            this._cache.removeImageContent(image.content);
+        image.content = content;
+        this._watchCacheFile(filename);
     },
 
     _removeAnimationTimeout: function() {
@@ -364,44 +495,59 @@
         }
     },
 
+    _updateAnimationProgress: function() {
+        if (this._images[1])
+            this._images[1].opacity = this._animation.transitionProgress * 255;
+
+        this._queueUpdateAnimation();
+    },
+
     _updateAnimation: function() {
         this._updateAnimationTimeoutId = 0;
 
         this._animation.update(this._layoutManager.monitors[this._monitorIndex]);
         let files = this._animation.keyFrameFiles;
 
-        let finish = Lang.bind(this, function() {
+        if (files.length == 0) {
             this._setLoaded();
-            if (files.length > 1) {
-                this.background.set_blend(files[0], files[1],
-                                          this._animation.transitionProgress,
-                                          this._style);
-            } else if (files.length > 0) {
-                this.background.set_file(files[0], this._style);
-            } else {
-                this.background.set_file(null, this._style);
-            }
             this._queueUpdateAnimation();
-        });
+            return;
+        }
 
-        let cache = Meta.BackgroundImageCache.get_default();
         let numPendingImages = files.length;
         for (let i = 0; i < files.length; i++) {
-            this._watchFile(files[i]);
-            let image = cache.load(files[i]);
-            if (image.is_loaded()) {
+            if (this._images[i] && this._images[i].content &&
+                this._images[i].content.get_filename() == files[i]) {
+
                 numPendingImages--;
                 if (numPendingImages == 0)
-                    finish();
-            } else {
-                let id = image.connect('loaded',
-                                       Lang.bind(this, function() {
-                                           image.disconnect(id);
-                                           numPendingImages--;
-                                           if (numPendingImages == 0)
-                                               finish();
-                                       }));
+                    this._updateAnimationProgress();
+                continue;
             }
+            this._cache.getImageContent({ monitorIndex: this._monitorIndex,
+                                          effects: this._effects,
+                                          style: this._style,
+                                          filename: files[i],
+                                          cancellable: this._cancellable,
+                                          onFinished: Lang.bind(this, function(content, i) {
+                                              numPendingImages--;
+
+                                              if (!content) {
+                                                  this._setLoaded();
+                                                  if (numPendingImages == 0)
+                                                      this._updateAnimationProgress();
+                                                  return;
+                                              }
+
+                                              this._ensureImage(i);
+                                              this._updateImage(i, content, files[i]);
+
+                                              if (numPendingImages == 0) {
+                                                  this._setLoaded();
+                                                  this._updateAnimationProgress();
+                                              }
+                                          }, i)
+                                        });
         }
     },
 
@@ -434,45 +580,44 @@
         GLib.Source.set_name_by_id(this._updateAnimationTimeoutId, '[gnome-shell] this._updateAnimation');
     },
 
-    _loadAnimation: function(file) {
-        this._cache.getAnimation({ file: file,
+    _loadAnimation: function(filename) {
+        this._cache.getAnimation({ filename: filename,
                                    settingsSchema: this._settings.schema_id,
-                                   onLoaded: Lang.bind(this, function(animation) {
-                                       this._animation = animation;
-
-                                       if (!this._animation || this._cancellable.is_cancelled()) {
-                                           this._setLoaded();
-                                           return;
-                                       }
-
-                                       this._updateAnimation();
-                                       this._watchFile(file);
-                                   })
-                                 });
-    },
+                                             onLoaded: Lang.bind(this, function(animation) {
+                                                 this._animation = animation;
 
-    _loadImage: function(file) {
-        this.background.set_file(file, this._style);
-        this._watchFile(file);
-
-        let cache = Meta.BackgroundImageCache.get_default();
-        let image = cache.load(file);
-        if (image.is_loaded())
-            this._setLoaded();
-        else {
-            let id = image.connect('loaded',
-                                   Lang.bind(this, function() {
-                                       this._setLoaded();
-                                       image.disconnect(id);
-                                   }));
-        }
-    },
-
-    _loadFile: function(file) {
-        if (file.get_basename().endsWith('.xml'))
-            this._loadAnimation(file);
+                                                 if (!this._animation || this._cancellable.is_cancelled()) {
+                                                     this._setLoaded();
+                                                     return;
+                                                 }
+
+                                                 this._updateAnimation();
+                                                 this._watchCacheFile(filename);
+                                             })
+                                           });
+    },
+
+    _loadImage: function(filename) {
+        this._cache.getImageContent({ monitorIndex: this._monitorIndex,
+                                      effects: this._effects,
+                                      style: this._style,
+                                      filename: filename,
+                                      cancellable: this._cancellable,
+                                      onFinished: Lang.bind(this, function(content) {
+                                          if (content) {
+                                              this._ensureImage(0);
+                                              this._updateImage(0, content, filename);
+                                          }
+                                          this._setLoaded();
+                                      })
+                                    });
+    },
+
+    _loadFile: function(filename) {
+        if (filename.endsWith('.xml'))
+            this._loadAnimation(filename);
         else
-            this._loadImage(file);
+            this._loadImage(filename);
     },
 
     _load: function () {
@@ -480,150 +625,103 @@
 
         this._loadPattern();
 
-        if (!this._file) {
+        let filename;
+        if (this._overrideImage != null) {
+            filename = this._overrideImage;
+            this._style = GDesktopEnums.BackgroundStyle.ZOOM; // Hardcode
+        } else {
+            this._style = this._settings.get_enum(BACKGROUND_STYLE_KEY);
+            if (this._style == GDesktopEnums.BackgroundStyle.NONE) {
+                this._setLoaded();
+                return;
+            }
+
+            let uri = this._settings.get_string(PICTURE_URI_KEY);
+            if (GLib.uri_parse_scheme(uri) != null)
+                filename = Gio.File.new_for_uri(uri).get_path();
+            else
+                filename = uri;
+        }
+
+        if (!filename) {
             this._setLoaded();
             return;
         }
 
-        this._loadFile(this._file);
+        this._loadFile(filename);
     },
-});
-Signals.addSignalMethods(Background.prototype);
 
-let _systemBackground;
-
-var SystemBackground = new Lang.Class({
-    Name: 'SystemBackground',
-
-    _init: function() {
-        let file = Gio.File.new_for_uri('resource:///org/gnome/shell/theme/noise-texture.png');
-
-        if (_systemBackground == null) {
-            _systemBackground = new Meta.Background({ meta_screen: global.screen });
-            _systemBackground.set_color(DEFAULT_BACKGROUND_COLOR);
-            _systemBackground.set_file(file, GDesktopEnums.BackgroundStyle.WALLPAPER);
-        }
-
-        this.actor = new Meta.BackgroundActor({ meta_screen: global.screen,
-                                                monitor: 0,
-                                                background: _systemBackground });
-
-        let cache = Meta.BackgroundImageCache.get_default();
-        let image = cache.load(file);
-        if (image.is_loaded()) {
-            image = null;
-            let id = GLib.idle_add(GLib.PRIORITY_DEFAULT, Lang.bind(this, function() {
-                this.emit('loaded');
-                return GLib.SOURCE_REMOVE;
-            }));
-            GLib.Source.set_name_by_id(id, '[gnome-shell] SystemBackground.loaded');
-        } else {
-            let id = image.connect('loaded',
-                                   Lang.bind(this, function() {
-                                       this.emit('loaded');
-                                       image.disconnect(id);
-                                       image = null;
-                                   }));
-        }
+    get brightness() {
+        return this._brightness;
     },
-});
-Signals.addSignalMethods(SystemBackground.prototype);
 
-var BackgroundSource = new Lang.Class({
-    Name: 'BackgroundSource',
+    set brightness(factor) {
+        this._brightness = factor;
+        if (this._pattern && this._pattern.content)
+            this._pattern.content.brightness = factor;
 
-    _init: function(layoutManager, settingsSchema) {
-        // Allow override the background image setting for performance testing
-        this._layoutManager = layoutManager;
-        this._overrideImage = GLib.getenv('SHELL_BACKGROUND_IMAGE');
-        this._settings = new Gio.Settings({ schema_id: settingsSchema });
-        this._backgrounds = [];
-
-        this._monitorsChangedId = global.screen.connect('monitors-changed',
-                                                        Lang.bind(this, this._onMonitorsChanged));
+        let keys = Object.keys(this._images);
+        for (let i = 0; i < keys.length; i++) {
+            let image = this._images[keys[i]];
+            if (image && image.content)
+                image.content.brightness = factor;
+        }
     },
 
-    _onMonitorsChanged: function() {
-        for (let monitorIndex in this._backgrounds) {
-            let background = this._backgrounds[monitorIndex];
-
-            if (monitorIndex < this._layoutManager.monitors.length) {
-                background.updateResolution();
-            } else {
-                background.disconnect(background._changedId);
-                background.destroy();
-                delete this._backgrounds[monitorIndex];
-            }
-        }
+    get vignetteSharpness() {
+        return this._vignetteSharpness;
     },
 
-    getBackground: function(monitorIndex) {
-        let file = null;
-        let style;
-
-        // We don't watch changes to settings here,
-        // instead we rely on Background to watch those
-        // and emit 'changed' at the right time
+    set vignetteSharpness(sharpness) {
+        this._vignetteSharpness = sharpness;
+        if (this._pattern && this._pattern.content)
+            this._pattern.content.vignette_sharpness = sharpness;
 
-        if (this._overrideImage != null) {
-            file = Gio.File.new_for_path(this._overrideImage);
-            style = GDesktopEnums.BackgroundStyle.ZOOM; // Hardcode
-        } else {
-            style = this._settings.get_enum(BACKGROUND_STYLE_KEY);
-            if (style != GDesktopEnums.BackgroundStyle.NONE) {
-                let uri = this._settings.get_string(PICTURE_URI_KEY);
-                file = Gio.File.new_for_commandline_arg(uri);
-            }
+        let keys = Object.keys(this._images);
+        for (let i = 0; i < keys.length; i++) {
+            let image = this._images[keys[i]];
+            if (image && image.content)
+                image.content.vignette_sharpness = sharpness;
         }
+    }
+});
+Signals.addSignalMethods(Background.prototype);
 
-        // Animated backgrounds are (potentially) per-monitor, since
-        // they can have variants that depend on the aspect ratio and
-        // size of the monitor; for other backgrounds we can use the
-        // same background object for all monitors.
-        if (file == null || !file.get_basename().endsWith('.xml'))
-            monitorIndex = 0;
-
-        if (!(monitorIndex in this._backgrounds)) {
-            let background = new Background({
-                monitorIndex: monitorIndex,
-                layoutManager: this._layoutManager,
-                settings: this._settings,
-                file: file,
-                style: style
-            });
+var SystemBackground = new Lang.Class({
+    Name: 'SystemBackground',
 
-            background._changedId = background.connect('changed', Lang.bind(this, function() {
-                background.disconnect(background._changedId);
-                background.destroy();
-                delete this._backgrounds[monitorIndex];
-            }));
+    _init: function() {
+        this._cache = getBackgroundCache();
+        this.actor = new Meta.BackgroundActor();
 
-            this._backgrounds[monitorIndex] = background;
-        }
+        this._cache.getImageContent({ style: GDesktopEnums.BackgroundStyle.WALLPAPER,
+                                      filename: global.datadir + '/theme/noise-texture.png',
+                                      effects: Meta.BackgroundEffects.NONE,
+                                      onFinished: Lang.bind(this, function(content) {
+                                          this.actor.content = content;
+                                          this.emit('loaded');
+                                      })
+                                    });
 
-        return this._backgrounds[monitorIndex];
+        this.actor.connect('destroy', Lang.bind(this, this._onDestroy));
     },
 
-    destroy: function() {
-        global.screen.disconnect(this._monitorsChangedId);
-
-        for (let monitorIndex in this._backgrounds) {
-            let background = this._backgrounds[monitorIndex];
-            background.disconnect(background._changedId);
-            background.destroy();
-        }
+    _onDestroy: function() {
+        let content = this.actor.content;
 
-        this._backgrounds = null;
-    }
+        if (content)
+            this._cache.removeImageContent(content);
+    },
 });
+Signals.addSignalMethods(SystemBackground.prototype);
 
 var Animation = new Lang.Class({
     Name: 'Animation',
 
     _init: function(params) {
-        params = Params.parse(params, { file: null });
+        params = Params.parse(params, { filename: null });
 
-        this.file = params.file;
+        this.filename = params.filename;
         this.keyFrameFiles = [];
         this.transitionProgress = 0.0;
         this.transitionDuration = 0.0;
@@ -631,7 +729,9 @@
     },
 
     load: function(callback) {
-        this._show = new GnomeDesktop.BGSlideShow({ filename: this.file.get_path() });
+        let file = Gio.File.new_for_path(this.filename);
+
+        this._show = new GnomeDesktop.BGSlideShow({ filename: this.filename });
 
         this._show.load_async(null,
                               Lang.bind(this,
@@ -651,143 +751,124 @@
         if (this._show.get_num_slides() < 1)
             return;
 
-        let [progress, duration, isFixed, filename1, filename2] = this._show.get_current_slide(monitor.width, monitor.height);
+        let [progress, duration, isFixed, file1, file2] = this._show.get_current_slide(monitor.width, monitor.height);
 
         this.transitionDuration = duration;
         this.transitionProgress = progress;
 
-        if (filename1)
-            this.keyFrameFiles.push(Gio.File.new_for_path(filename1));
+        if (file1)
+            this.keyFrameFiles.push(file1);
 
-        if (filename2)
-            this.keyFrameFiles.push(Gio.File.new_for_path(filename2));
+        if (file2)
+            this.keyFrameFiles.push(file2);
     },
 });
 Signals.addSignalMethods(Animation.prototype);
 
-var BackgroundManager = new Lang.Class({
+const BackgroundManager = new Lang.Class({
     Name: 'BackgroundManager',
 
     _init: function(params) {
         params = Params.parse(params, { container: null,
                                         layoutManager: Main.layoutManager,
                                         monitorIndex: null,
-                                        vignette: false,
+                                        effects: Meta.BackgroundEffects.NONE,
                                         controlPosition: true,
                                         settingsSchema: BACKGROUND_SCHEMA });
 
-        let cache = getBackgroundCache();
-        this._settingsSchema = params.settingsSchema;
-        this._backgroundSource = cache.getBackgroundSource(params.layoutManager, params.settingsSchema);
-
+        // Allow override the background image setting for performance testing
+        this._overrideImage = GLib.getenv('SHELL_BACKGROUND_IMAGE');
+        this._settings = new Gio.Settings({ schema_id: params.settingsSchema });
         this._container = params.container;
         this._layoutManager = params.layoutManager;
-        this._vignette = params.vignette;
+        this._effects = params.effects;
         this._monitorIndex = params.monitorIndex;
         this._controlPosition = params.controlPosition;
 
-        this.backgroundActor = this._createBackgroundActor();
-        this._newBackgroundActor = null;
+        this.background = this._createBackground();
+        this.backgroundActor = this.background.actor;
+        this._newBackground = null;
     },
 
     destroy: function() {
-        let cache = getBackgroundCache();
-        cache.releaseBackgroundSource(this._settingsSchema);
-        this._backgroundSource = null;
-
-        if (this._newBackgroundActor) {
-            this._newBackgroundActor.destroy();
-            this._newBackgroundActor = null;
+        if (this._newBackground) {
+            this._newBackground.actor.destroy();
+            this._newBackground = null;
         }
 
-        if (this.backgroundActor) {
-            this.backgroundActor.destroy();
+        if (this.background) {
+            this.background.actor.destroy();
+            this.background = null;
             this.backgroundActor = null;
         }
     },
 
-    _swapBackgroundActor: function() {
-        let oldBackgroundActor = this.backgroundActor;
-        this.backgroundActor = this._newBackgroundActor;
-        this._newBackgroundActor = null;
-        this.emit('changed');
-
-        Tweener.addTween(oldBackgroundActor,
-                         { opacity: 0,
-                           time: FADE_ANIMATION_TIME,
-                           transition: 'easeOutQuad',
-                           onComplete: function() {
-                               oldBackgroundActor.background.run_dispose();
-                               oldBackgroundActor.destroy();
-                           }
-                         });
-    },
+    _updateBackground: function() {
+        let newBackground = this._createBackground();
+        newBackground.vignetteSharpness = this.background.vignetteSharpness;
+        newBackground.brightness = this.background.brightness;
+        newBackground.visible = this.background.visible;
 
-    _updateBackgroundActor: function() {
-        if (this._newBackgroundActor) {
-            /* Skip displaying existing background queued for load */
-            this._newBackgroundActor.destroy();
-            this._newBackgroundActor = null;
-        }
-
-        let newBackgroundActor = this._createBackgroundActor();
-        newBackgroundActor.vignette_sharpness = this.backgroundActor.vignette_sharpness;
-        newBackgroundActor.brightness = this.backgroundActor.brightness;
-        newBackgroundActor.visible = this.backgroundActor.visible;
-
-        this._newBackgroundActor = newBackgroundActor;
+        newBackground.loadedSignalId = newBackground.connect('loaded',
+            Lang.bind(this, function() {
+                newBackground.disconnect(newBackground.loadedSignalId);
+                newBackground.loadedSignalId = 0;
 
-        let background = newBackgroundActor.background._delegate;
+                if (this._newBackground != newBackground) {
+                    /* Not interesting, we queued another load */
+                    newBackground.actor.destroy();
+                    return;
+                }
 
-        if (background.isLoaded) {
-            this._swapBackgroundActor();
-        } else {
-            newBackgroundActor.loadedSignalId = background.connect('loaded',
-                Lang.bind(this, function() {
-                    background.disconnect(newBackgroundActor.loadedSignalId);
-                    newBackgroundActor.loadedSignalId = 0;
+                Tweener.addTween(this.background.actor,
+                                 { opacity: 0,
+                                   time: FADE_ANIMATION_TIME,
+                                   transition: 'easeOutQuad',
+                                   onComplete: Lang.bind(this, function() {
+                                       this.background.actor.run_dispose();
+                                       this.background.actor.destroy();
+                                       this.background = newBackground;
+                                       this._newBackground = null;
 
-                    this._swapBackgroundActor();
+                                       this.emit('changed');
+                                   })
+                                 });
+        }));
 
-                }));
-        }
+        this._newBackground = newBackground;
     },
 
-    _createBackgroundActor: function() {
-        let background = this._backgroundSource.getBackground(this._monitorIndex);
-        let backgroundActor = new Meta.BackgroundActor({ meta_screen: global.screen,
-                                                         monitor: this._monitorIndex,
-                                                         background: background.background,
-                                                         vignette: this._vignette,
-                                                         vignette_sharpness: 0.5,
-                                                         brightness: 0.5,
-                                                       });
-
-        this._container.add_child(backgroundActor);
+    _createBackground: function() {
+        let background = new Background({ monitorIndex: this._monitorIndex,
+                                          layoutManager: this._layoutManager,
+                                          effects: this._effects,
+                                          settings: this._settings,
+                                          overrideImage: this._overrideImage });
+        this._container.add_child(background.actor);
 
         let monitor = this._layoutManager.monitors[this._monitorIndex];
 
-        backgroundActor.set_size(monitor.width, monitor.height);
+        background.actor.set_size(monitor.width, monitor.height);
         if (this._controlPosition) {
-            backgroundActor.set_position(monitor.x, monitor.y);
-            backgroundActor.lower_bottom();
+            background.actor.set_position(monitor.x, monitor.y);
+            background.actor.lower_bottom();
         }
 
-        let changeSignalId = background.connect('changed', Lang.bind(this, function() {
-            background.disconnect(changeSignalId);
-            changeSignalId = null;
-            this._updateBackgroundActor();
+        background.changeSignalId = background.connect('changed', Lang.bind(this, function() {
+            background.disconnect(background.changeSignalId);
+            background.changeSignalId = 0;
+            this._updateBackground();
         }));
 
-        backgroundActor.connect('destroy', Lang.bind(this, function() {
-            if (changeSignalId)
-                background.disconnect(changeSignalId);
+        background.actor.connect('destroy', Lang.bind(this, function() {
+            if (background.changeSignalId)
+                background.disconnect(background.changeSignalId);
 
-            if (backgroundActor.loadedSignalId)
-                background.disconnect(backgroundActor.loadedSignalId);
+            if (background.loadedSignalId)
+                background.disconnect(background.loadedSignalId);
         }));
 
-        return backgroundActor;
+        return background;
     },
 });
 Signals.addSignalMethods(BackgroundManager.prototype);
diff '--exclude=.git' -urN a/js/ui/layout.js b/js/ui/layout.js
--- a/js/ui/layout.js	2017-10-04 12:14:12.000000000 -0400
+++ b/js/ui/layout.js	2017-10-11 19:46:15.503914394 -0400
@@ -11,7 +11,6 @@
 
 const Background = imports.ui.background;
 const BackgroundMenu = imports.ui.backgroundMenu;
-const LoginManager = imports.misc.loginManager;
 
 const DND = imports.ui.dnd;
 const Main = imports.ui.main;
@@ -21,6 +20,7 @@
 var STARTUP_ANIMATION_TIME = 0.5;
 var KEYBOARD_ANIMATION_TIME = 0.15;
 var BACKGROUND_FADE_ANIMATION_TIME = 1.0;
+var DEFAULT_BACKGROUND_COLOR = Clutter.Color.from_pixel(0x2e3436ff);
 
 var HOT_CORNER_PRESSURE_THRESHOLD = 100; // pixels
 var HOT_CORNER_PRESSURE_TIMEOUT = 1000; // ms
@@ -194,10 +194,10 @@
         this._startingUp = true;
         this._pendingLoadBackground = false;
 
-        // We don't want to paint the stage background color because either
-        // the SystemBackground we create or the MetaBackgroundActor inside
-        // global.window_group covers the entirety of the screen.
-        global.stage.no_clear_hint = true;
+        // Normally, the stage is always covered so Clutter doesn't need to clear
+        // it; however it becomes visible during the startup animation
+        // See the comment below for a longer explanation
+        global.stage.background_color = DEFAULT_BACKGROUND_COLOR;
 
         // Set up stage hierarchy to group all UI actors under one container.
         this.uiGroup = new Shell.GenericContainer({ name: 'uiGroup' });
@@ -279,18 +279,6 @@
         global.screen.connect('in-fullscreen-changed',
                               Lang.bind(this, this._updateFullscreen));
         this._monitorsChanged();
-
-        // NVIDIA drivers don't preserve FBO contents across
-        // suspend/resume, see
-        // https://bugzilla.gnome.org/show_bug.cgi?id=739178
-        if (Shell.util_need_background_refresh()) {
-            LoginManager.getLoginManager().connect('prepare-for-sleep',
-                                                   function(lm, suspending) {
-                                                       if (suspending)
-                                                           return;
-                                                       Meta.Background.refresh_all();
-                                                   });
-        }
     },
 
     // This is called by Main after everything else is constructed
@@ -414,7 +402,7 @@
     },
 
     _addBackgroundMenu: function(bgManager) {
-        BackgroundMenu.addBackgroundMenu(bgManager.backgroundActor, this);
+        BackgroundMenu.addBackgroundMenu(bgManager.background.actor, this);
     },
 
     _createBackgroundManager: function(monitorIndex) {
@@ -431,10 +419,10 @@
     _showSecondaryBackgrounds: function() {
         for (let i = 0; i < this.monitors.length; i++) {
             if (i != this.primaryIndex) {
-                let backgroundActor = this._bgManagers[i].backgroundActor;
-                backgroundActor.show();
-                backgroundActor.opacity = 0;
-                Tweener.addTween(backgroundActor,
+                let background = this._bgManagers[i].background;
+                background.actor.show();
+                background.actor.opacity = 0;
+                Tweener.addTween(background.actor,
                                  { opacity: 255,
                                    time: BACKGROUND_FADE_ANIMATION_TIME,
                                    transition: 'easeOutQuad' });
@@ -457,7 +445,7 @@
             this._bgManagers.push(bgManager);
 
             if (i != this.primaryIndex && this._startingUp)
-                bgManager.backgroundActor.hide();
+                bgManager.background.actor.hide();
         }
     },
 
@@ -604,6 +592,10 @@
     //
     // When starting a normal user session, we want to grow it out of the middle
     // of the screen.
+    //
+    // Usually, we don't want to paint the stage background color because the
+    // MetaBackgroundActor inside global.window_group covers the entirety of the
+    // screen. So, we set no_clear_hint at the end of the animation.
 
     _prepareStartupAnimation: function() {
         // During the initial transition, add a simple actor to block all events,
@@ -686,6 +678,10 @@
     },
 
     _startupAnimationComplete: function() {
+        // At this point, the UI group is covering everything, so
+        // we no longer need to clear the stage
+        global.stage.no_clear_hint = true;
+
         this._coverPane.destroy();
         this._coverPane = null;
 
diff '--exclude=.git' -urN a/js/ui/magnifier.js b/js/ui/magnifier.js
--- a/js/ui/magnifier.js	2017-10-04 12:14:12.000000000 -0400
+++ b/js/ui/magnifier.js	2017-10-11 19:45:13.489224402 -0400
@@ -1227,7 +1227,12 @@
 
         // Add a background for when the magnified uiGroup is scrolled
         // out of view (don't want to see desktop showing through).
-        this._background = (new Background.SystemBackground()).actor;
+        this._background = new Clutter.Actor({ background_color: Main.DEFAULT_BACKGROUND_COLOR,
+                                               layout_manager: new Clutter.BinLayout(),
+                                               width: global.screen_width,
+                                               height: global.screen_height });
+        let noiseTexture = (new Background.SystemBackground()).actor;
+        this._background.add_actor(noiseTexture);
         mainGroup.add_actor(this._background);
 
         // Clone the group that contains all of UI on the screen.  This is the
diff '--exclude=.git' -urN a/js/ui/main.js b/js/ui/main.js
--- a/js/ui/main.js	2017-10-04 12:14:12.000000000 -0400
+++ b/js/ui/main.js	2017-10-11 19:53:38.237700582 -0400
@@ -45,6 +45,8 @@
 const XdndHandler = imports.ui.xdndHandler;
 const Util = imports.misc.util;
 
+var DEFAULT_BACKGROUND_COLOR = Clutter.Color.from_pixel(0x2e3436ff);
+
 const A11Y_SCHEMA = 'org.gnome.desktop.a11y.keyboard';
 const STICKY_KEYS_ENABLE = 'stickykeys-enable';
 const GNOMESHELL_STARTED_MESSAGE_ID = 'f3ea493c22934e26811cd62abe8e203a';
diff '--exclude=.git' -urN a/js/ui/overview.js b/js/ui/overview.js
--- a/js/ui/overview.js	2017-10-04 12:14:12.000000000 -0400
+++ b/js/ui/overview.js	2017-10-11 19:45:13.489224402 -0400
@@ -179,7 +179,7 @@
         for (let i = 0; i < Main.layoutManager.monitors.length; i++) {
             let bgManager = new Background.BackgroundManager({ container: this._backgroundGroup,
                                                                monitorIndex: i,
-                                                               vignette: true });
+                                                               effects: Meta.BackgroundEffects.VIGNETTE });
             this._bgManagers.push(bgManager);
         }
     },
@@ -187,9 +187,11 @@
     _unshadeBackgrounds: function() {
         let backgrounds = this._backgroundGroup.get_children();
         for (let i = 0; i < backgrounds.length; i++) {
-            Tweener.addTween(backgrounds[i],
+            let background = backgrounds[i]._delegate;
+
+            Tweener.addTween(background,
                              { brightness: 1.0,
-                               vignette_sharpness: 0.0,
+                               vignetteSharpness: 0.0,
                                time: SHADE_ANIMATION_TIME,
                                transition: 'easeOutQuad'
                              });
@@ -199,9 +201,11 @@
     _shadeBackgrounds: function() {
         let backgrounds = this._backgroundGroup.get_children();
         for (let i = 0; i < backgrounds.length; i++) {
-            Tweener.addTween(backgrounds[i],
+            let background = backgrounds[i]._delegate;
+
+            Tweener.addTween(background,
                              { brightness: Lightbox.VIGNETTE_BRIGHTNESS,
-                               vignette_sharpness: Lightbox.VIGNETTE_SHARPNESS,
+                               vignetteSharpness: Lightbox.VIGNETTE_SHARPNESS,
                                time: SHADE_ANIMATION_TIME,
                                transition: 'easeOutQuad'
                              });
diff '--exclude=.git' -urN a/js/ui/workspaceThumbnail.js b/js/ui/workspaceThumbnail.js
--- a/js/ui/workspaceThumbnail.js	2017-10-04 12:14:12.000000000 -0400
+++ b/js/ui/workspaceThumbnail.js	2017-10-11 19:45:13.490224397 -0400
@@ -317,7 +317,7 @@
     _createBackground: function() {
         this._bgManager = new Background.BackgroundManager({ monitorIndex: Main.layoutManager.primaryIndex,
                                                              container: this._contents,
-                                                             vignette: false });
+                                                             effects: Meta.BackgroundEffects.NONE });
     },
 
     setPorthole: function(x, y, width, height) {
@@ -343,7 +343,7 @@
             let clone = this._windows[i];
             let metaWindow = clone.metaWindow;
             if (i == 0) {
-                clone.setStackAbove(this._bgManager.backgroundActor);
+                clone.setStackAbove(this._bgManager.background.actor);
             } else {
                 let previousClone = this._windows[i - 1];
                 clone.setStackAbove(previousClone.actor);
@@ -542,7 +542,7 @@
         this._contents.add_actor(clone.actor);
 
         if (this._windows.length == 0)
-            clone.setStackAbove(this._bgManager.backgroundActor);
+            clone.setStackAbove(this._bgManager.background.actor);
         else
             clone.setStackAbove(this._windows[this._windows.length - 1].actor);
 
diff '--exclude=.git' -urN a/src/shell-util.c b/src/shell-util.c
--- a/src/shell-util.c	2017-10-04 12:14:12.000000000 -0400
+++ b/src/shell-util.c	2017-10-11 19:45:13.490224397 -0400
@@ -5,9 +5,6 @@
 #include <sys/types.h>
 #include <sys/wait.h>
 
-#include <GL/gl.h>
-#include <cogl/cogl.h>
-
 #include "shell-util.h"
 #include <glib/gi18n-lib.h>
 #include <gtk/gtk.h>
@@ -378,36 +375,6 @@
     }
 }
 
-typedef const gchar *(*ShellGLGetString) (GLenum);
-
-static const gchar *
-get_gl_vendor (void)
-{
-  static const gchar *vendor = NULL;
-
-  if (!vendor)
-    {
-      ShellGLGetString gl_get_string;
-      gl_get_string = (ShellGLGetString) cogl_get_proc_address ("glGetString");
-      if (gl_get_string)
-        vendor = gl_get_string (GL_VENDOR);
-    }
-
-  return vendor;
-}
-
-gboolean
-shell_util_need_background_refresh (void)
-{
-  if (!clutter_check_windowing_backend (CLUTTER_WINDOWING_X11))
-    return FALSE;
-
-  if (g_strcmp0 (get_gl_vendor (), "NVIDIA Corporation") == 0)
-    return TRUE;
-
-  return FALSE;
-}
-
 static gboolean
 canvas_draw_cb (ClutterContent *content,
                 cairo_t        *cr,
diff '--exclude=.git' -urN a/src/shell-util.h b/src/shell-util.h
--- a/src/shell-util.h	2017-10-04 12:14:12.000000000 -0400
+++ b/src/shell-util.h	2017-10-11 19:45:13.490224397 -0400
@@ -48,8 +48,6 @@
 void    shell_util_cursor_tracker_to_clutter (MetaCursorTracker *tracker,
                                               ClutterTexture    *texture);
 
-gboolean shell_util_need_background_refresh (void);
-
 ClutterContent * shell_util_get_content_for_window_actor (MetaWindowActor *window_actor,
                                                           MetaRectangle   *window_rect);
 
